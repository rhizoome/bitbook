#!/usr/bin/env python3

import sys
import re
import json
import tomllib
from enum import Enum

class State(Enum):
    BLOCK_INACTIVE = 0
    BLOCK_ACTIVE = 1

def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def format(css_class, block_lines):
    block_content = "".join(block_lines)
    return f"<div class=\"{css_class}\">\n\n{block_content}\n</div>\n\n"

class_pattern = re.compile(r"^\s*\{\:([ \w-]+)\:\}\s*$")
front_pattern = re.compile(r"^\s*```toml\s*$")
end_pattern = re.compile(r"^\s*```\s*$")

def get_frontmatter(content):
    lines = content.splitlines(keepends=True)
    matter = []
    add = matter.append
    if front_pattern.match(lines[0]):
        index = 3
        for line in lines[1:]:
            if end_pattern.match(line):
                return "".join(lines[index:]), tomllib.loads("".join(matter))
            else:
                index += 1
                add(line)
    else:
        return content, {}

def class_hint(content):
    state = State.BLOCK_INACTIVE
    css_class = None
    block_lines = []
    output_lines = []
    output = output_lines.append
    for line in content.splitlines(keepends=True):
        if state == State.BLOCK_INACTIVE:
            # Check if line starts a block
            match = class_pattern.match(line)
            if match:
                state = State.BLOCK_ACTIVE
                css_class = match.group(1)
                block_lines = []
            else:
                # Just pass normal lines through
                output(line)
        elif  state == State.BLOCK_ACTIVE:
            # An empty line designates the end of the block
            if line.strip() == "":
                # Print the block inside a <div> with class `css_class`
                output(format(css_class, block_lines))
                state = State.BLOCK_INACTIVE
                css_class = None
                block_lines = []
            else:
                # Accumulate lines in the block
                block_lines.append(line)
        else:
            raise NotImplementedError()
    

    # If input ended while still in BLOCK_ACTIVE state), print what we have
    if state == State.BLOCK_ACTIVE:
        output(format(css_class, block_lines))
    return "".join(output_lines)

def first_pass(context, book, item):
    chapter = item["Chapter"]
    context["chapters"].append(chapter)
    content = chapter["content"]
    content, chapter["sp-frontmatter"] = get_frontmatter(content)
    content = class_hint(content)
    chapter["content"] = content

def second_pass(context, book, item):
    chapter = item["Chapter"]
    if chapter["name"] == "BitBook":
        content = chapter["content"]
        content = content.replace("{-sp-news-}", "# News")
        chapter["content"] = content

def do_items(context, book, item, do_pass):
    do_pass(context, book, item)
    chapter = item["Chapter"]
    for sub_item in chapter["sub_items"]:
        do_items(context, book, sub_item, do_pass)

def run(context, book, do_pass):
    for section in book["sections"]:
        do_items(context, book, section, do_pass)
    return context, book

if __name__ == "__main__":
    if len(sys.argv) > 1: # we check if we received any argument
        if sys.argv[1] == "supports": 
            sys.exit(0)

    context, book = json.load(sys.stdin)
    context["chapters"] = []
    context, book = run(context, book, first_pass)
    context, book = run(context, book, second_pass)
    print(json.dumps(book))
